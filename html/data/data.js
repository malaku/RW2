var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"MalaksModelSub/RW1 Steering Angle","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"C:\\Users\\16134\\Desktop\\masters\\Model\\RW1_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: ert_main.c\r\n *\r\n * Code generated for Simulink model 'RW1'.\r\n *\r\n * Model version                  : 1.63\r\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\r\n * C/C++ source code generated on : Thu Nov  9 17:34:04 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (MATLAB Host)\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include \"RW1.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"limits.h\"\r\n#include \"linuxinitialize.h\"\r\n#define UNUSED(x)                      x = x\r\n#define NAMELEN                        16\r\n\r\n/* Function prototype declaration*/\r\nvoid exitFcn(int sig);\r\nvoid *terminateTask(void *arg);\r\nvoid *baseRateTask(void *arg);\r\nvoid *subrateTask(void *arg);\r\nvolatile boolean_T stopRequested = false;\r\nvolatile boolean_T runModel = true;\r\nsem_t stopSem;\r\nsem_t baserateTaskSem;\r\npthread_t schedulerThread;\r\npthread_t baseRateThread;\r\nvoid *threadJoinStatus;\r\nint terminatingmodel = 0;\r\nvoid *baseRateTask(void *arg)\r\n{\r\n  runModel = (rtmGetErrorStatus(rtM) == (NULL)) && !rtmGetStopRequested(rtM);\r\n  while (runModel) {\r\n    sem_wait(&baserateTaskSem);\r\n    RW1_step();\r\n\r\n    /* Get model outputs here */\r\n    stopRequested = !((rtmGetErrorStatus(rtM) == (NULL)) && !rtmGetStopRequested\r\n                      (rtM));\r\n    runModel = !stopRequested;\r\n  }\r\n\r\n  runModel = 0;\r\n  terminateTask(arg);\r\n  pthread_exit((void *)0);\r\n  return NULL;\r\n}\r\n\r\nvoid exitFcn(int sig)\r\n{\r\n  UNUSED(sig);\r\n  rtmSetErrorStatus(rtM, \"stopping the model\");\r\n}\r\n\r\nvoid *terminateTask(void *arg)\r\n{\r\n  UNUSED(arg);\r\n  terminatingmodel = 1;\r\n\r\n  {\r\n    runModel = 0;\r\n  }\r\n\r\n  sem_post(&stopSem);\r\n  return NULL;\r\n}\r\n\r\nint main(int argc, char **argv)\r\n{\r\n  rtmSetErrorStatus(rtM, 0);\r\n\r\n  /* Initialize model */\r\n  RW1_initialize();\r\n\r\n  /* Call RTOS Initialization function */\r\n  myRTOSInit(0.01, 0);\r\n\r\n  /* Wait for stop semaphore */\r\n  sem_wait(&stopSem);\r\n\r\n#if (MW_NUMBER_TIMER_DRIVEN_TASKS > 0)\r\n\r\n  {\r\n    int i;\r\n    for (i=0; i < MW_NUMBER_TIMER_DRIVEN_TASKS; i++) {\r\n      CHECK_STATUS(sem_destroy(&timerTaskSem[i]), 0, \"sem_destroy\");\r\n    }\r\n  }\r\n\r\n#endif\r\n\r\n  return 0;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"RW1.c","type":"source","group":"model","path":"C:\\Users\\16134\\Desktop\\masters\\Model\\RW1_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: RW1.c\r\n *\r\n * Code generated for Simulink model 'RW1'.\r\n *\r\n * Model version                  : 1.63\r\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\r\n * C/C++ source code generated on : Thu Nov  9 17:34:04 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (MATLAB Host)\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"RW1.h\"\r\n#include \"rtwtypes.h\"\r\n#include <math.h>\r\n\r\n/* Private macros used by the generated code to access rtModel */\r\n#ifndef rtmIsMajorTimeStep\r\n#define rtmIsMajorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MAJOR_TIME_STEP)\r\n#endif\r\n\r\n#ifndef rtmIsMinorTimeStep\r\n#define rtmIsMinorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MINOR_TIME_STEP)\r\n#endif\r\n\r\n#ifndef rtmSetTPtr\r\n#define rtmSetTPtr(rtm, val)           ((rtm)->Timing.t = (val))\r\n#endif\r\n\r\n/* Continuous states */\r\nX rtX;\r\n\r\n/* Block signals and states (default storage) */\r\nDW rtDW;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nExtU rtU;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nExtY rtY;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL rtM_;\r\nRT_MODEL *const rtM = &rtM_;\r\nstatic void RW1SteeringAngle_Init(DW_RW1SteeringAngle *localDW,\r\n  P_RW1SteeringAngle *localP, X_RW1SteeringAngle *localX);\r\nstatic void RW1SteeringAngle_Deriv(real_T rtu_desiredrw1, real_T rtu_Fx, real_T\r\n  rtu_Fy, real_T *rty_Actualrw1, DW_RW1SteeringAngle *localDW,\r\n  P_RW1SteeringAngle *localP, X_RW1SteeringAngle *localX, XDot_RW1SteeringAngle *\r\n  localXdot);\r\nstatic void RW1SteeringAngle_Update(RT_MODEL * const rtM, real_T *rty_Actualrw1,\r\n  DW_RW1SteeringAngle *localDW);\r\nstatic void RW1SteeringAngle(RT_MODEL * const rtM, real_T *rty_Actualrw1,\r\n  DW_RW1SteeringAngle *localDW, P_RW1SteeringAngle *localP, X_RW1SteeringAngle\r\n  *localX);\r\n\r\n/* private model entry point functions */\r\nextern void RW1_derivatives(void);\r\n\r\n/*\r\n * This function updates continuous states using the ODE4 fixed-step\r\n * solver algorithm\r\n */\r\nstatic void rt_ertODEUpdateContinuousStates(RTWSolverInfo *si )\r\n{\r\n  time_T t = rtsiGetT(si);\r\n  time_T tnew = rtsiGetSolverStopTime(si);\r\n  time_T h = rtsiGetStepSize(si);\r\n  real_T *x = rtsiGetContStates(si);\r\n  ODE4_IntgData *id = (ODE4_IntgData *)rtsiGetSolverData(si);\r\n  real_T *y = id->y;\r\n  real_T *f0 = id->f[0];\r\n  real_T *f1 = id->f[1];\r\n  real_T *f2 = id->f[2];\r\n  real_T *f3 = id->f[3];\r\n  real_T temp;\r\n  int_T i;\r\n  int_T nXc = 5;\r\n  rtsiSetSimTimeStep(si,MINOR_TIME_STEP);\r\n\r\n  /* Save the state values at time t in y, we'll use x as ynew. */\r\n  (void) memcpy(y, x,\r\n                (uint_T)nXc*sizeof(real_T));\r\n\r\n  /* Assumes that rtsiSetT and ModelOutputs are up-to-date */\r\n  /* f0 = f(t,y) */\r\n  rtsiSetdX(si, f0);\r\n  RW1_derivatives();\r\n\r\n  /* f1 = f(t + (h/2), y + (h/2)*f0) */\r\n  temp = 0.5 * h;\r\n  for (i = 0; i < nXc; i++) {\r\n    x[i] = y[i] + (temp*f0[i]);\r\n  }\r\n\r\n  rtsiSetT(si, t + temp);\r\n  rtsiSetdX(si, f1);\r\n  RW1_step();\r\n  RW1_derivatives();\r\n\r\n  /* f2 = f(t + (h/2), y + (h/2)*f1) */\r\n  for (i = 0; i < nXc; i++) {\r\n    x[i] = y[i] + (temp*f1[i]);\r\n  }\r\n\r\n  rtsiSetdX(si, f2);\r\n  RW1_step();\r\n  RW1_derivatives();\r\n\r\n  /* f3 = f(t + h, y + h*f2) */\r\n  for (i = 0; i < nXc; i++) {\r\n    x[i] = y[i] + (h*f2[i]);\r\n  }\r\n\r\n  rtsiSetT(si, tnew);\r\n  rtsiSetdX(si, f3);\r\n  RW1_step();\r\n  RW1_derivatives();\r\n\r\n  /* tnew = t + h\r\n     ynew = y + (h/6)*(f0 + 2*f1 + 2*f2 + 2*f3) */\r\n  temp = h / 6.0;\r\n  for (i = 0; i < nXc; i++) {\r\n    x[i] = y[i] + temp*(f0[i] + 2.0*f1[i] + 2.0*f2[i] + f3[i]);\r\n  }\r\n\r\n  rtsiSetSimTimeStep(si,MAJOR_TIME_STEP);\r\n}\r\n\r\n/* System initialize for atomic system: '<Root>/RW1 Steering Angle' */\r\nstatic void RW1SteeringAngle_Init(DW_RW1SteeringAngle *localDW,\r\n  P_RW1SteeringAngle *localP, X_RW1SteeringAngle *localX)\r\n{\r\n  /* InitializeConditions for TransferFcn: '<S1>/Transfer Fcn1' */\r\n  localX->TransferFcn1_CSTATE = 0.0;\r\n\r\n  /* InitializeConditions for Integrator: '<S37>/Integrator' */\r\n  localX->Integrator_CSTATE =\r\n    localP->PIDController_InitialConditionForIntegrator;\r\n\r\n  /* InitializeConditions for Integrator: '<S1>/Integrator' */\r\n  localX->Integrator_CSTATE_e = localP->Integrator_IC;\r\n\r\n  /* InitializeConditions for Memory: '<S4>/Memory4' */\r\n  localDW->Memory4_PreviousInput = localP->Memory4_InitialCondition;\r\n\r\n  /* InitializeConditions for Memory: '<S4>/Memory3' */\r\n  localDW->Memory3_PreviousInput = localP->Memory3_InitialCondition;\r\n\r\n  /* InitializeConditions for Integrator: '<S32>/Filter' */\r\n  localX->Filter_CSTATE = localP->PIDController_InitialConditionForFilter;\r\n\r\n  /* InitializeConditions for TransferFcn: '<S1>/Transfer Fcn' */\r\n  localX->TransferFcn_CSTATE = 0.0;\r\n}\r\n\r\n/* Outputs for atomic system: '<Root>/RW1 Steering Angle' */\r\nstatic void RW1SteeringAngle(RT_MODEL * const rtM, real_T *rty_Actualrw1,\r\n  DW_RW1SteeringAngle *localDW, P_RW1SteeringAngle *localP, X_RW1SteeringAngle\r\n  *localX)\r\n{\r\n  /* TransferFcn: '<S1>/Transfer Fcn1' */\r\n  localDW->theta_D = localP->TransferFcn1_C * localX->TransferFcn1_CSTATE;\r\n\r\n  /* Gain: '<S1>/Back EMF Constant' */\r\n  localDW->BackEMFConstant = rtP.Ke * localDW->theta_D;\r\n\r\n  /* Integrator: '<S37>/Integrator' */\r\n  localDW->Integrator = localX->Integrator_CSTATE;\r\n  if (rtmIsMajorTimeStep(rtM)) {\r\n    /* Memory: '<S4>/Memory4' */\r\n    localDW->Memory4 = localDW->Memory4_PreviousInput;\r\n\r\n    /* Memory: '<S4>/Memory3' */\r\n    localDW->Memory3 = localDW->Memory3_PreviousInput;\r\n  }\r\n\r\n  /* MATLAB Function: '<S4>/Switch' incorporates:\r\n   *  Integrator: '<S1>/Integrator'\r\n   */\r\n  localDW->d = localX->Integrator_CSTATE_e;\r\n\r\n  /* MATLAB Function: '<S4>/Ratchet' incorporates:\r\n   *  Integrator: '<S1>/Integrator'\r\n   *  MATLAB Function: '<S4>/Switch'\r\n   */\r\n  if (localX->Integrator_CSTATE_e > localDW->Memory3) {\r\n    if (localX->Integrator_CSTATE_e > localDW->Memory4) {\r\n      *rty_Actualrw1 = localX->Integrator_CSTATE_e;\r\n    } else {\r\n      *rty_Actualrw1 = localDW->Memory4;\r\n    }\r\n  } else if (localDW->Memory4 > localX->Integrator_CSTATE_e) {\r\n    *rty_Actualrw1 = localX->Integrator_CSTATE_e;\r\n  } else {\r\n    *rty_Actualrw1 = localDW->Memory4;\r\n  }\r\n\r\n  /* End of MATLAB Function: '<S4>/Ratchet' */\r\n\r\n  /* Integrator: '<S32>/Filter' */\r\n  localDW->Filter = localX->Filter_CSTATE;\r\n\r\n  /* Gain: '<S1>/Torque Constant' incorporates:\r\n   *  TransferFcn: '<S1>/Transfer Fcn'\r\n   */\r\n  localDW->MotorTorque = localP->TransferFcn_C * localX->TransferFcn_CSTATE *\r\n    rtP.Ka;\r\n}\r\n\r\n/* Update for atomic system: '<Root>/RW1 Steering Angle' */\r\nstatic void RW1SteeringAngle_Update(RT_MODEL * const rtM, real_T *rty_Actualrw1,\r\n  DW_RW1SteeringAngle *localDW)\r\n{\r\n  if (rtmIsMajorTimeStep(rtM)) {\r\n    /* Update for Memory: '<S4>/Memory4' */\r\n    localDW->Memory4_PreviousInput = *rty_Actualrw1;\r\n\r\n    /* Update for Memory: '<S4>/Memory3' */\r\n    localDW->Memory3_PreviousInput = localDW->d;\r\n  }\r\n}\r\n\r\n/* Derivatives for atomic system: '<Root>/RW1 Steering Angle' */\r\nstatic void RW1SteeringAngle_Deriv(real_T rtu_desiredrw1, real_T rtu_Fx, real_T\r\n  rtu_Fy, real_T *rty_Actualrw1, DW_RW1SteeringAngle *localDW,\r\n  P_RW1SteeringAngle *localP, X_RW1SteeringAngle *localX, XDot_RW1SteeringAngle *\r\n  localXdot)\r\n{\r\n  real_T FilterCoefficient;\r\n  real_T I_f;\r\n  real_T Sum4;\r\n  real_T rtb_slipangle;\r\n\r\n  /* Sum: '<S1>/Sum4' */\r\n  Sum4 = rtu_desiredrw1 - *rty_Actualrw1;\r\n\r\n  /* Gain: '<S40>/Filter Coefficient' incorporates:\r\n   *  Gain: '<S31>/Derivative Gain'\r\n   *  Sum: '<S32>/SumD'\r\n   */\r\n  FilterCoefficient = (localP->PIDController_D * Sum4 - localDW->Filter) *\r\n    localP->PIDController_N;\r\n\r\n  /* Gain: '<S1>/Gain2' */\r\n  rtb_slipangle = 1.0 / rtP.cs1 * rtu_Fy;\r\n\r\n  /* MATLAB Function: '<S1>/pneumatic trail ' incorporates:\r\n   *  Constant: '<S1>/Constant'\r\n   *  Constant: '<S1>/Constant1'\r\n   *  Constant: '<S1>/Constant2'\r\n   *  Constant: '<S1>/Constant3'\r\n   */\r\n  I_f = 1.0 / (rtP.mu * rtP.Ws1);\r\n  if (fabs(rtb_slipangle) <= atan(3.0 / (rtP.cs1 * I_f))) {\r\n    rtb_slipangle = rtP.tpo - rtP.tpo * rtP.cs1 * I_f * tan(rtb_slipangle) / 3.0;\r\n  } else {\r\n    rtb_slipangle = 0.0;\r\n  }\r\n\r\n  /* End of MATLAB Function: '<S1>/pneumatic trail ' */\r\n\r\n  /* Derivatives for TransferFcn: '<S1>/Transfer Fcn1' incorporates:\r\n   *  MATLAB Function: '<S1>/MATLAB Function'\r\n   *  Sum: '<S1>/Sum1'\r\n   */\r\n  localXdot->TransferFcn1_CSTATE = localP->TransferFcn1_A *\r\n    localX->TransferFcn1_CSTATE;\r\n  localXdot->TransferFcn1_CSTATE += localDW->MotorTorque - (rtu_Fx * 0.15 +\r\n    rtu_Fy * rtb_slipangle);\r\n\r\n  /* Derivatives for Integrator: '<S37>/Integrator' incorporates:\r\n   *  Gain: '<S34>/Integral Gain'\r\n   */\r\n  localXdot->Integrator_CSTATE = localP->PIDController_I * Sum4;\r\n\r\n  /* Derivatives for Integrator: '<S1>/Integrator' */\r\n  localXdot->Integrator_CSTATE_e = localDW->theta_D;\r\n\r\n  /* Derivatives for Integrator: '<S32>/Filter' */\r\n  localXdot->Filter_CSTATE = FilterCoefficient;\r\n\r\n  /* Derivatives for TransferFcn: '<S1>/Transfer Fcn' incorporates:\r\n   *  Gain: '<S1>/Power Amplifier'\r\n   *  Gain: '<S42>/Proportional Gain'\r\n   *  Sum: '<S1>/Sum'\r\n   *  Sum: '<S46>/Sum'\r\n   */\r\n  localXdot->TransferFcn_CSTATE = localP->TransferFcn_A *\r\n    localX->TransferFcn_CSTATE;\r\n  localXdot->TransferFcn_CSTATE += ((localP->PIDController_P * Sum4 +\r\n    localDW->Integrator) + FilterCoefficient) * localP->PowerAmplifier_Gain -\r\n    localDW->BackEMFConstant;\r\n}\r\n\r\n/* Model step function */\r\nvoid RW1_step(void)\r\n{\r\n  if (rtmIsMajorTimeStep(rtM)) {\r\n    /* set solver stop time */\r\n    rtsiSetSolverStopTime(&rtM->solverInfo,((rtM->Timing.clockTick0+1)*\r\n      rtM->Timing.stepSize0));\r\n  }                                    /* end MajorTimeStep */\r\n\r\n  /* Update absolute time of base rate at minor time step */\r\n  if (rtmIsMinorTimeStep(rtM)) {\r\n    rtM->Timing.t[0] = rtsiGetT(&rtM->solverInfo);\r\n  }\r\n\r\n  /* Outputs for Atomic SubSystem: '<Root>/RW1 Steering Angle' */\r\n  RW1SteeringAngle(rtM, &rtDW.y, &rtDW.RW1SteeringAngle_m,\r\n                   &rtP.RW1SteeringAngle_m, &rtX.RW1SteeringAngle_m);\r\n\r\n  /* End of Outputs for SubSystem: '<Root>/RW1 Steering Angle' */\r\n\r\n  /* Outport: '<Root>/Actual rw1' */\r\n  rtY.Actualrw1 = rtDW.y;\r\n  if (rtmIsMajorTimeStep(rtM)) {\r\n    /* Update for Atomic SubSystem: '<Root>/RW1 Steering Angle' */\r\n\r\n    /* Update for Inport: '<Root>/desired rw1' incorporates:\r\n     *  Inport: '<Root>/Fx'\r\n     *  Inport: '<Root>/Fy'\r\n     */\r\n    RW1SteeringAngle_Update(rtM, &rtDW.y, &rtDW.RW1SteeringAngle_m);\r\n\r\n    /* End of Update for SubSystem: '<Root>/RW1 Steering Angle' */\r\n  }                                    /* end MajorTimeStep */\r\n\r\n  if (rtmIsMajorTimeStep(rtM)) {\r\n    rt_ertODEUpdateContinuousStates(&rtM->solverInfo);\r\n\r\n    /* Update absolute time for base rate */\r\n    /* The \"clockTick0\" counts the number of times the code of this task has\r\n     * been executed. The absolute time is the multiplication of \"clockTick0\"\r\n     * and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not\r\n     * overflow during the application lifespan selected.\r\n     */\r\n    ++rtM->Timing.clockTick0;\r\n    rtM->Timing.t[0] = rtsiGetSolverStopTime(&rtM->solverInfo);\r\n\r\n    {\r\n      /* Update absolute timer for sample time: [0.01s, 0.0s] */\r\n      /* The \"clockTick1\" counts the number of times the code of this task has\r\n       * been executed. The resolution of this integer timer is 0.01, which is the step size\r\n       * of the task. Size of \"clockTick1\" ensures timer will not overflow during the\r\n       * application lifespan selected.\r\n       */\r\n      rtM->Timing.clockTick1++;\r\n    }\r\n  }                                    /* end MajorTimeStep */\r\n}\r\n\r\n/* Derivatives for root system: '<Root>' */\r\nvoid RW1_derivatives(void)\r\n{\r\n  XDot *_rtXdot;\r\n  _rtXdot = ((XDot *) rtM->derivs);\r\n\r\n  /* Derivatives for Atomic SubSystem: '<Root>/RW1 Steering Angle' */\r\n\r\n  /* Derivatives for Inport: '<Root>/desired rw1' incorporates:\r\n   *  Inport: '<Root>/Fx'\r\n   *  Inport: '<Root>/Fy'\r\n   */\r\n  RW1SteeringAngle_Deriv(rtU.desiredrw1, rtU.Fx, rtU.Fy, &rtDW.y,\r\n    &rtDW.RW1SteeringAngle_m, &rtP.RW1SteeringAngle_m, &rtX.RW1SteeringAngle_m,\r\n    &_rtXdot->RW1SteeringAngle_m);\r\n\r\n  /* End of Derivatives for SubSystem: '<Root>/RW1 Steering Angle' */\r\n}\r\n\r\n/* Model initialize function */\r\nvoid RW1_initialize(void)\r\n{\r\n  /* Registration code */\r\n  {\r\n    /* Setup solver object */\r\n    rtsiSetSimTimeStepPtr(&rtM->solverInfo, &rtM->Timing.simTimeStep);\r\n    rtsiSetTPtr(&rtM->solverInfo, &rtmGetTPtr(rtM));\r\n    rtsiSetStepSizePtr(&rtM->solverInfo, &rtM->Timing.stepSize0);\r\n    rtsiSetdXPtr(&rtM->solverInfo, &rtM->derivs);\r\n    rtsiSetContStatesPtr(&rtM->solverInfo, (real_T **) &rtM->contStates);\r\n    rtsiSetNumContStatesPtr(&rtM->solverInfo, &rtM->Sizes.numContStates);\r\n    rtsiSetNumPeriodicContStatesPtr(&rtM->solverInfo,\r\n      &rtM->Sizes.numPeriodicContStates);\r\n    rtsiSetPeriodicContStateIndicesPtr(&rtM->solverInfo,\r\n      &rtM->periodicContStateIndices);\r\n    rtsiSetPeriodicContStateRangesPtr(&rtM->solverInfo,\r\n      &rtM->periodicContStateRanges);\r\n    rtsiSetErrorStatusPtr(&rtM->solverInfo, (&rtmGetErrorStatus(rtM)));\r\n    rtsiSetRTModelPtr(&rtM->solverInfo, rtM);\r\n  }\r\n\r\n  rtsiSetSimTimeStep(&rtM->solverInfo, MAJOR_TIME_STEP);\r\n  rtM->intgData.y = rtM->odeY;\r\n  rtM->intgData.f[0] = rtM->odeF[0];\r\n  rtM->intgData.f[1] = rtM->odeF[1];\r\n  rtM->intgData.f[2] = rtM->odeF[2];\r\n  rtM->intgData.f[3] = rtM->odeF[3];\r\n  rtM->contStates = ((X *) &rtX);\r\n  rtsiSetSolverData(&rtM->solverInfo, (void *)&rtM->intgData);\r\n  rtsiSetIsMinorTimeStepWithModeChange(&rtM->solverInfo, false);\r\n  rtsiSetSolverName(&rtM->solverInfo,\"ode4\");\r\n  rtmSetTPtr(rtM, &rtM->Timing.tArray[0]);\r\n  rtM->Timing.stepSize0 = 0.01;\r\n\r\n  /* SystemInitialize for Atomic SubSystem: '<Root>/RW1 Steering Angle' */\r\n  RW1SteeringAngle_Init(&rtDW.RW1SteeringAngle_m, &rtP.RW1SteeringAngle_m,\r\n                        &rtX.RW1SteeringAngle_m);\r\n\r\n  /* End of SystemInitialize for SubSystem: '<Root>/RW1 Steering Angle' */\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"RW1.h","type":"header","group":"model","path":"C:\\Users\\16134\\Desktop\\masters\\Model\\RW1_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: RW1.h\r\n *\r\n * Code generated for Simulink model 'RW1'.\r\n *\r\n * Model version                  : 1.63\r\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\r\n * C/C++ source code generated on : Thu Nov  9 17:34:04 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (MATLAB Host)\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_RW1_h_\r\n#define RTW_HEADER_RW1_h_\r\n#ifndef RW1_COMMON_INCLUDES_\r\n#define RW1_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#include \"rtw_continuous.h\"\r\n#include \"rtw_solver.h\"\r\n#endif                                 /* RW1_COMMON_INCLUDES_ */\r\n\r\n#include <string.h>\r\n#include <stddef.h>\r\n\r\n/* Model Code Variants */\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetContStateDisabled\r\n#define rtmGetContStateDisabled(rtm)   ((rtm)->contStateDisabled)\r\n#endif\r\n\r\n#ifndef rtmSetContStateDisabled\r\n#define rtmSetContStateDisabled(rtm, val) ((rtm)->contStateDisabled = (val))\r\n#endif\r\n\r\n#ifndef rtmGetContStates\r\n#define rtmGetContStates(rtm)          ((rtm)->contStates)\r\n#endif\r\n\r\n#ifndef rtmSetContStates\r\n#define rtmSetContStates(rtm, val)     ((rtm)->contStates = (val))\r\n#endif\r\n\r\n#ifndef rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag\r\n#define rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm) ((rtm)->CTOutputIncnstWithState)\r\n#endif\r\n\r\n#ifndef rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag\r\n#define rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm, val) ((rtm)->CTOutputIncnstWithState = (val))\r\n#endif\r\n\r\n#ifndef rtmGetDerivCacheNeedsReset\r\n#define rtmGetDerivCacheNeedsReset(rtm) ((rtm)->derivCacheNeedsReset)\r\n#endif\r\n\r\n#ifndef rtmSetDerivCacheNeedsReset\r\n#define rtmSetDerivCacheNeedsReset(rtm, val) ((rtm)->derivCacheNeedsReset = (val))\r\n#endif\r\n\r\n#ifndef rtmGetIntgData\r\n#define rtmGetIntgData(rtm)            ((rtm)->intgData)\r\n#endif\r\n\r\n#ifndef rtmSetIntgData\r\n#define rtmSetIntgData(rtm, val)       ((rtm)->intgData = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOdeF\r\n#define rtmGetOdeF(rtm)                ((rtm)->odeF)\r\n#endif\r\n\r\n#ifndef rtmSetOdeF\r\n#define rtmSetOdeF(rtm, val)           ((rtm)->odeF = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOdeY\r\n#define rtmGetOdeY(rtm)                ((rtm)->odeY)\r\n#endif\r\n\r\n#ifndef rtmSetOdeY\r\n#define rtmSetOdeY(rtm, val)           ((rtm)->odeY = (val))\r\n#endif\r\n\r\n#ifndef rtmGetPeriodicContStateIndices\r\n#define rtmGetPeriodicContStateIndices(rtm) ((rtm)->periodicContStateIndices)\r\n#endif\r\n\r\n#ifndef rtmSetPeriodicContStateIndices\r\n#define rtmSetPeriodicContStateIndices(rtm, val) ((rtm)->periodicContStateIndices = (val))\r\n#endif\r\n\r\n#ifndef rtmGetPeriodicContStateRanges\r\n#define rtmGetPeriodicContStateRanges(rtm) ((rtm)->periodicContStateRanges)\r\n#endif\r\n\r\n#ifndef rtmSetPeriodicContStateRanges\r\n#define rtmSetPeriodicContStateRanges(rtm, val) ((rtm)->periodicContStateRanges = (val))\r\n#endif\r\n\r\n#ifndef rtmGetZCCacheNeedsReset\r\n#define rtmGetZCCacheNeedsReset(rtm)   ((rtm)->zCCacheNeedsReset)\r\n#endif\r\n\r\n#ifndef rtmSetZCCacheNeedsReset\r\n#define rtmSetZCCacheNeedsReset(rtm, val) ((rtm)->zCCacheNeedsReset = (val))\r\n#endif\r\n\r\n#ifndef rtmGetdX\r\n#define rtmGetdX(rtm)                  ((rtm)->derivs)\r\n#endif\r\n\r\n#ifndef rtmSetdX\r\n#define rtmSetdX(rtm, val)             ((rtm)->derivs = (val))\r\n#endif\r\n\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((rtm)->Timing.stopRequestedFlag)\r\n#endif\r\n\r\n#ifndef rtmSetStopRequested\r\n#define rtmSetStopRequested(rtm, val)  ((rtm)->Timing.stopRequestedFlag = (val))\r\n#endif\r\n\r\n#ifndef rtmGetStopRequestedPtr\r\n#define rtmGetStopRequestedPtr(rtm)    (&((rtm)->Timing.stopRequestedFlag))\r\n#endif\r\n\r\n#ifndef rtmGetT\r\n#define rtmGetT(rtm)                   (rtmGetTPtr((rtm))[0])\r\n#endif\r\n\r\n#ifndef rtmGetTPtr\r\n#define rtmGetTPtr(rtm)                ((rtm)->Timing.t)\r\n#endif\r\n\r\n#define RW1_M                          (rtM)\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM RT_MODEL;\r\n\r\n/* Block signals and states (default storage) for system '<Root>/RW1 Steering Angle' */\r\ntypedef struct {\r\n  real_T theta_D;                      /* '<S1>/Transfer Fcn1' */\r\n  real_T BackEMFConstant;              /* '<S1>/Back EMF Constant' */\r\n  real_T Integrator;                   /* '<S37>/Integrator' */\r\n  real_T Memory4;                      /* '<S4>/Memory4' */\r\n  real_T Memory3;                      /* '<S4>/Memory3' */\r\n  real_T Filter;                       /* '<S32>/Filter' */\r\n  real_T MotorTorque;                  /* '<S1>/Torque Constant' */\r\n  real_T d;                            /* '<S4>/Switch' */\r\n  real_T Memory4_PreviousInput;        /* '<S4>/Memory4' */\r\n  real_T Memory3_PreviousInput;        /* '<S4>/Memory3' */\r\n} DW_RW1SteeringAngle;\r\n\r\n/* Continuous states for system '<Root>/RW1 Steering Angle' */\r\ntypedef struct {\r\n  real_T TransferFcn1_CSTATE;          /* '<S1>/Transfer Fcn1' */\r\n  real_T Integrator_CSTATE;            /* '<S37>/Integrator' */\r\n  real_T Integrator_CSTATE_e;          /* '<S1>/Integrator' */\r\n  real_T Filter_CSTATE;                /* '<S32>/Filter' */\r\n  real_T TransferFcn_CSTATE;           /* '<S1>/Transfer Fcn' */\r\n} X_RW1SteeringAngle;\r\n\r\n/* State derivatives for system '<Root>/RW1 Steering Angle' */\r\ntypedef struct {\r\n  real_T TransferFcn1_CSTATE;          /* '<S1>/Transfer Fcn1' */\r\n  real_T Integrator_CSTATE;            /* '<S37>/Integrator' */\r\n  real_T Integrator_CSTATE_e;          /* '<S1>/Integrator' */\r\n  real_T Filter_CSTATE;                /* '<S32>/Filter' */\r\n  real_T TransferFcn_CSTATE;           /* '<S1>/Transfer Fcn' */\r\n} XDot_RW1SteeringAngle;\r\n\r\n/* State Disabled for system '<Root>/RW1 Steering Angle' */\r\ntypedef struct {\r\n  boolean_T TransferFcn1_CSTATE;       /* '<S1>/Transfer Fcn1' */\r\n  boolean_T Integrator_CSTATE;         /* '<S37>/Integrator' */\r\n  boolean_T Integrator_CSTATE_e;       /* '<S1>/Integrator' */\r\n  boolean_T Filter_CSTATE;             /* '<S32>/Filter' */\r\n  boolean_T TransferFcn_CSTATE;        /* '<S1>/Transfer Fcn' */\r\n} XDis_RW1SteeringAngle;\r\n\r\n/* Block signals and states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  DW_RW1SteeringAngle RW1SteeringAngle_m;/* '<Root>/RW1 Steering Angle' */\r\n  real_T y;                            /* '<S4>/Ratchet' */\r\n} DW;\r\n\r\n/* Continuous states (default storage) */\r\ntypedef struct {\r\n  X_RW1SteeringAngle RW1SteeringAngle_m;/* '<Root>/RW1 Steering Angle' */\r\n} X;\r\n\r\n/* State derivatives (default storage) */\r\ntypedef struct {\r\n  XDot_RW1SteeringAngle RW1SteeringAngle_m;/* '<Root>/RW1 Steering Angle' */\r\n} XDot;\r\n\r\n/* State disabled  */\r\ntypedef struct {\r\n  XDis_RW1SteeringAngle RW1SteeringAngle_m;/* '<Root>/RW1 Steering Angle' */\r\n} XDis;\r\n\r\n#ifndef ODE4_INTG\r\n#define ODE4_INTG\r\n\r\n/* ODE4 Integration Data */\r\ntypedef struct {\r\n  real_T *y;                           /* output */\r\n  real_T *f[4];                        /* derivatives */\r\n} ODE4_IntgData;\r\n\r\n#endif\r\n\r\n/* External inputs (root inport signals with default storage) */\r\ntypedef struct {\r\n  real_T desiredrw1;                   /* '<Root>/desired rw1' */\r\n  real_T Fx;                           /* '<Root>/Fx' */\r\n  real_T Fy;                           /* '<Root>/Fy' */\r\n} ExtU;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\ntypedef struct {\r\n  real_T Actualrw1;                    /* '<Root>/Actual rw1' */\r\n} ExtY;\r\n\r\n/* Parameters for system: '<Root>/RW1 Steering Angle' */\r\nstruct P_RW1SteeringAngle_ {\r\n  real_T PIDController_D;              /* Mask Parameter: PIDController_D\r\n                                        * Referenced by: '<S31>/Derivative Gain'\r\n                                        */\r\n  real_T PIDController_I;              /* Mask Parameter: PIDController_I\r\n                                        * Referenced by: '<S34>/Integral Gain'\r\n                                        */\r\n  real_T PIDController_InitialConditionForFilter;\r\n                      /* Mask Parameter: PIDController_InitialConditionForFilter\r\n                       * Referenced by: '<S32>/Filter'\r\n                       */\r\n  real_T PIDController_InitialConditionForIntegrator;\r\n                  /* Mask Parameter: PIDController_InitialConditionForIntegrator\r\n                   * Referenced by: '<S37>/Integrator'\r\n                   */\r\n  real_T PIDController_N;              /* Mask Parameter: PIDController_N\r\n                                        * Referenced by: '<S40>/Filter Coefficient'\r\n                                        */\r\n  real_T PIDController_P;              /* Mask Parameter: PIDController_P\r\n                                        * Referenced by: '<S42>/Proportional Gain'\r\n                                        */\r\n  real_T PowerAmplifier_Gain;          /* Expression: 25\r\n                                        * Referenced by: '<S1>/Power Amplifier'\r\n                                        */\r\n  real_T TransferFcn1_A;               /* Computed Parameter: TransferFcn1_A\r\n                                        * Referenced by: '<S1>/Transfer Fcn1'\r\n                                        */\r\n  real_T TransferFcn1_C;               /* Computed Parameter: TransferFcn1_C\r\n                                        * Referenced by: '<S1>/Transfer Fcn1'\r\n                                        */\r\n  real_T Integrator_IC;                /* Expression: 0\r\n                                        * Referenced by: '<S1>/Integrator'\r\n                                        */\r\n  real_T Memory4_InitialCondition;     /* Expression: 0\r\n                                        * Referenced by: '<S4>/Memory4'\r\n                                        */\r\n  real_T Memory3_InitialCondition;     /* Expression: 0\r\n                                        * Referenced by: '<S4>/Memory3'\r\n                                        */\r\n  real_T TransferFcn_A;                /* Computed Parameter: TransferFcn_A\r\n                                        * Referenced by: '<S1>/Transfer Fcn'\r\n                                        */\r\n  real_T TransferFcn_C;                /* Computed Parameter: TransferFcn_C\r\n                                        * Referenced by: '<S1>/Transfer Fcn'\r\n                                        */\r\n};\r\n\r\n/* Parameters for system: '<Root>/RW1 Steering Angle' */\r\ntypedef struct P_RW1SteeringAngle_ P_RW1SteeringAngle;\r\n\r\n/* Parameters (default storage) */\r\nstruct P_ {\r\n  real_T Ka;                           /* Variable: Ka\r\n                                        * Referenced by: '<S1>/Torque Constant'\r\n                                        */\r\n  real_T Ke;                           /* Variable: Ke\r\n                                        * Referenced by: '<S1>/Back EMF Constant'\r\n                                        */\r\n  real_T Ws1;                          /* Variable: Ws1\r\n                                        * Referenced by: '<S1>/Constant'\r\n                                        */\r\n  real_T cs1;                          /* Variable: cs1\r\n                                        * Referenced by:\r\n                                        *   '<S1>/Constant2'\r\n                                        *   '<S1>/Gain2'\r\n                                        */\r\n  real_T mu;                           /* Variable: mu\r\n                                        * Referenced by: '<S1>/Constant3'\r\n                                        */\r\n  real_T tpo;                          /* Variable: tpo\r\n                                        * Referenced by: '<S1>/Constant1'\r\n                                        */\r\n  P_RW1SteeringAngle RW1SteeringAngle_m;/* '<Root>/RW1 Steering Angle' */\r\n};\r\n\r\n/* Parameters (default storage) */\r\ntypedef struct P_ P;\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM {\r\n  const char_T *errorStatus;\r\n  RTWSolverInfo solverInfo;\r\n  X *contStates;\r\n  int_T *periodicContStateIndices;\r\n  real_T *periodicContStateRanges;\r\n  real_T *derivs;\r\n  boolean_T *contStateDisabled;\r\n  boolean_T zCCacheNeedsReset;\r\n  boolean_T derivCacheNeedsReset;\r\n  boolean_T CTOutputIncnstWithState;\r\n  real_T odeY[5];\r\n  real_T odeF[4][5];\r\n  ODE4_IntgData intgData;\r\n\r\n  /*\r\n   * Sizes:\r\n   * The following substructure contains sizes information\r\n   * for many of the model attributes such as inputs, outputs,\r\n   * dwork, sample times, etc.\r\n   */\r\n  struct {\r\n    int_T numContStates;\r\n    int_T numPeriodicContStates;\r\n    int_T numSampTimes;\r\n  } Sizes;\r\n\r\n  /*\r\n   * Timing:\r\n   * The following substructure contains information regarding\r\n   * the timing information for the model.\r\n   */\r\n  struct {\r\n    uint32_T clockTick0;\r\n    time_T stepSize0;\r\n    uint32_T clockTick1;\r\n    SimTimeStep simTimeStep;\r\n    boolean_T stopRequestedFlag;\r\n    time_T *t;\r\n    time_T tArray[2];\r\n  } Timing;\r\n};\r\n\r\n/* Block parameters (default storage) */\r\nextern P rtP;\r\n\r\n/* Continuous states (default storage) */\r\nextern X rtX;\r\n\r\n/* Block signals and states (default storage) */\r\nextern DW rtDW;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nextern ExtU rtU;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nextern ExtY rtY;\r\n\r\n/* Model entry point functions */\r\nextern void RW1_initialize(void);\r\nextern void RW1_step(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL *const rtM;\r\n\r\n/*-\r\n * These blocks were eliminated from the model due to optimizations:\r\n *\r\n * Block '<S1>/Scope' : Unused code path elimination\r\n * Block '<S1>/Scope1' : Unused code path elimination\r\n * Block '<S1>/Scope2' : Unused code path elimination\r\n * Block '<S1>/Scope4' : Unused code path elimination\r\n * Block '<S1>/Scope5' : Unused code path elimination\r\n * Block '<S1>/Scope6' : Unused code path elimination\r\n */\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Note that this particular code originates from a subsystem build,\r\n * and has its own system numbers different from the parent model.\r\n * Refer to the system hierarchy for this subsystem below, and use the\r\n * MATLAB hilite_system command to trace the generated code back\r\n * to the parent model.  For example,\r\n *\r\n * hilite_system('MalaksModelSub/RW1 Steering Angle')    - opens subsystem MalaksModelSub/RW1 Steering Angle\r\n * hilite_system('MalaksModelSub/RW1 Steering Angle/Kp') - opens and selects block Kp\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'MalaksModelSub'\r\n * '<S1>'   : 'MalaksModelSub/RW1 Steering Angle'\r\n * '<S2>'   : 'MalaksModelSub/RW1 Steering Angle/MATLAB Function'\r\n * '<S3>'   : 'MalaksModelSub/RW1 Steering Angle/PID Controller'\r\n * '<S4>'   : 'MalaksModelSub/RW1 Steering Angle/Ratchet'\r\n * '<S5>'   : 'MalaksModelSub/RW1 Steering Angle/pneumatic trail '\r\n * '<S6>'   : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Anti-windup'\r\n * '<S7>'   : 'MalaksModelSub/RW1 Steering Angle/PID Controller/D Gain'\r\n * '<S8>'   : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Filter'\r\n * '<S9>'   : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Filter ICs'\r\n * '<S10>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/I Gain'\r\n * '<S11>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Ideal P Gain'\r\n * '<S12>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Ideal P Gain Fdbk'\r\n * '<S13>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Integrator'\r\n * '<S14>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Integrator ICs'\r\n * '<S15>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/N Copy'\r\n * '<S16>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/N Gain'\r\n * '<S17>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/P Copy'\r\n * '<S18>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Parallel P Gain'\r\n * '<S19>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Reset Signal'\r\n * '<S20>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Saturation'\r\n * '<S21>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Saturation Fdbk'\r\n * '<S22>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Sum'\r\n * '<S23>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Sum Fdbk'\r\n * '<S24>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Tracking Mode'\r\n * '<S25>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Tracking Mode Sum'\r\n * '<S26>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Tsamp - Integral'\r\n * '<S27>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Tsamp - Ngain'\r\n * '<S28>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/postSat Signal'\r\n * '<S29>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/preSat Signal'\r\n * '<S30>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Anti-windup/Passthrough'\r\n * '<S31>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/D Gain/Internal Parameters'\r\n * '<S32>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Filter/Cont. Filter'\r\n * '<S33>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Filter ICs/Internal IC - Filter'\r\n * '<S34>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/I Gain/Internal Parameters'\r\n * '<S35>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Ideal P Gain/Passthrough'\r\n * '<S36>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Ideal P Gain Fdbk/Disabled'\r\n * '<S37>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Integrator/Continuous'\r\n * '<S38>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Integrator ICs/Internal IC'\r\n * '<S39>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/N Copy/Disabled'\r\n * '<S40>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/N Gain/Internal Parameters'\r\n * '<S41>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/P Copy/Disabled'\r\n * '<S42>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Parallel P Gain/Internal Parameters'\r\n * '<S43>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Reset Signal/Disabled'\r\n * '<S44>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Saturation/Passthrough'\r\n * '<S45>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Saturation Fdbk/Disabled'\r\n * '<S46>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Sum/Sum_PID'\r\n * '<S47>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Sum Fdbk/Disabled'\r\n * '<S48>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Tracking Mode/Disabled'\r\n * '<S49>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Tracking Mode Sum/Passthrough'\r\n * '<S50>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Tsamp - Integral/Passthrough'\r\n * '<S51>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/Tsamp - Ngain/Passthrough'\r\n * '<S52>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/postSat Signal/Forward_Path'\r\n * '<S53>'  : 'MalaksModelSub/RW1 Steering Angle/PID Controller/preSat Signal/Forward_Path'\r\n * '<S54>'  : 'MalaksModelSub/RW1 Steering Angle/Ratchet/Ratchet'\r\n * '<S55>'  : 'MalaksModelSub/RW1 Steering Angle/Ratchet/Switch'\r\n */\r\n#endif                                 /* RTW_HEADER_RW1_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"RW1_data.c","type":"source","group":"data","path":"C:\\Users\\16134\\Desktop\\masters\\Model\\RW1_ert_rtw","tag":"","groupDisplay":"Data files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: RW1_data.c\r\n *\r\n * Code generated for Simulink model 'RW1'.\r\n *\r\n * Model version                  : 1.63\r\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\r\n * C/C++ source code generated on : Thu Nov  9 17:34:04 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (MATLAB Host)\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"RW1.h\"\r\n\r\n/* Block parameters (default storage) */\r\nP rtP = {\r\n  /* Variable: Ka\r\n   * Referenced by: '<S1>/Torque Constant'\r\n   */\r\n  2.5,\r\n\r\n  /* Variable: Ke\r\n   * Referenced by: '<S1>/Back EMF Constant'\r\n   */\r\n  0.168,\r\n\r\n  /* Variable: Ws1\r\n   * Referenced by: '<S1>/Constant'\r\n   */\r\n  4622.9115276693683,\r\n\r\n  /* Variable: cs1\r\n   * Referenced by:\r\n   *   '<S1>/Constant2'\r\n   *   '<S1>/Gain2'\r\n   */\r\n  4500.0,\r\n\r\n  /* Variable: mu\r\n   * Referenced by: '<S1>/Constant3'\r\n   */\r\n  0.8,\r\n\r\n  /* Variable: tpo\r\n   * Referenced by: '<S1>/Constant1'\r\n   */\r\n  0.033333333333333333,\r\n\r\n  /* Start of '<Root>/RW1 Steering Angle' */\r\n  {\r\n    /* Mask Parameter: PIDController_D\r\n     * Referenced by: '<S31>/Derivative Gain'\r\n     */\r\n    -0.104094170262672,\r\n\r\n    /* Mask Parameter: PIDController_I\r\n     * Referenced by: '<S34>/Integral Gain'\r\n     */\r\n    43.6325510006951,\r\n\r\n    /* Mask Parameter: PIDController_InitialConditionForFilter\r\n     * Referenced by: '<S32>/Filter'\r\n     */\r\n    0.0,\r\n\r\n    /* Mask Parameter: PIDController_InitialConditionForIntegrator\r\n     * Referenced by: '<S37>/Integrator'\r\n     */\r\n    0.0,\r\n\r\n    /* Mask Parameter: PIDController_N\r\n     * Referenced by: '<S40>/Filter Coefficient'\r\n     */\r\n    43.2081582371269,\r\n\r\n    /* Mask Parameter: PIDController_P\r\n     * Referenced by: '<S42>/Proportional Gain'\r\n     */\r\n    4.49771738027195,\r\n\r\n    /* Expression: 25\r\n     * Referenced by: '<S1>/Power Amplifier'\r\n     */\r\n    25.0,\r\n\r\n    /* Computed Parameter: TransferFcn1_A\r\n     * Referenced by: '<S1>/Transfer Fcn1'\r\n     */\r\n    -0.0033534540576794104,\r\n\r\n    /* Computed Parameter: TransferFcn1_C\r\n     * Referenced by: '<S1>/Transfer Fcn1'\r\n     */\r\n    33.5345405767941,\r\n\r\n    /* Expression: 0\r\n     * Referenced by: '<S1>/Integrator'\r\n     */\r\n    0.0,\r\n\r\n    /* Expression: 0\r\n     * Referenced by: '<S4>/Memory4'\r\n     */\r\n    0.0,\r\n\r\n    /* Expression: 0\r\n     * Referenced by: '<S4>/Memory3'\r\n     */\r\n    0.0,\r\n\r\n    /* Computed Parameter: TransferFcn_A\r\n     * Referenced by: '<S1>/Transfer Fcn'\r\n     */\r\n    -33.755274261603375,\r\n\r\n    /* Computed Parameter: TransferFcn_C\r\n     * Referenced by: '<S1>/Transfer Fcn'\r\n     */\r\n    210.97046413502107\r\n  }\r\n  /* End of '<Root>/RW1 Steering Angle' */\r\n};\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\16134\\Desktop\\masters\\Model\\RW1_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model 'RW1'.\r\n *\r\n * Model version                  : 1.63\r\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\r\n * C/C++ source code generated on : Thu Nov  9 17:34:04 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (MATLAB Host)\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: MATLAB Host\r\n *   Number of bits:     char:   8    short:   16    int:  32\r\n *                       long:  32    long long:  64\r\n *                       native word size:  64\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef long long int64_T;\r\ntypedef unsigned long long uint64_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T, ulonglong_T.           *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef unsigned long long ulonglong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"C:\\Users\\16134\\Desktop\\masters\\Model\\RW1_ert_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtmodel.h\r\n *\r\n * Code generated for Simulink model 'RW1'.\r\n *\r\n * Model version                  : 1.63\r\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\r\n * C/C++ source code generated on : Thu Nov  9 17:34:04 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (MATLAB Host)\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtmodel_h_\r\n#define RTW_HEADER_rtmodel_h_\r\n#include \"RW1.h\"\r\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"MW_custom_RTOS_header.h","type":"header","group":"other","path":"C:\\Users\\16134\\Desktop\\masters\\Model\\RW1_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef _MW_CUSTOM_RTOS_HEADER_H_\r\n#define _MW_CUSTOM_RTOS_HEADER_H_\r\n#define MW_BASERATE_PRIORITY           40\r\n#define MW_BASERATE_PERIOD             0.01\r\n#define MW_NUMBER_SUBRATES             0\r\n#define MW_NUMBER_APERIODIC_TASKS      0\r\n#define MW_IS_CONCURRENT               0\r\n#define MW_NUMBER_TIMER_DRIVEN_TASKS   0\r\n\r\nextern void exitFcn(int sig);\r\nextern void *terminateTask(void *arg);\r\nextern void *baseRateTask(void *arg);\r\nextern void *subrateTask(void *arg);\r\nextern pthread_t schedulerThread;\r\nextern pthread_t baseRateThread;\r\nextern pthread_t subRateThread[];\r\nextern sem_t stopSem;\r\nextern sem_t baserateTaskSem;\r\nextern sem_t subrateTaskSem[];\r\nextern int taskId[];\r\nextern int subratePriority[];\r\n\r\n#endif\r\n\r\n#define MW_MAX_TASKNAME                16\r\n"},{"name":"MW_target_hardware_resources.h","type":"header","group":"other","path":"C:\\Users\\16134\\Desktop\\masters\\Model\\RW1_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef PORTABLE_WORDSIZES\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#ifndef __MW_TARGET_HARDWARE_RESOURCES_H__\n#define __MW_TARGET_HARDWARE_RESOURCES_H__\n\n#define MW_MULTI_TASKING_MODE 1\n\n#define MW_USECODERTARGET 1\n#define MW_TARGETHARDWARE BeagleBone Black\n#define MW_CONNECTIONINFO_TCPIP_IPADDRESS codertarget.beaglebone.internal.getBoardParam('Hostname')\n#define MW_CONNECTIONINFO_TCPIP_PORT 17725\n#define MW_CONNECTIONINFO_TCPIP_VERBOSE 0\n#define MW_CONNECTIONINFO_TCPIP_RUNINBACKGROUND 1\n#define MW_EXTMODE_CONFIGURATION TCP/IP\n#define MW_RTOS Linux\n#define MW_RTOSBASERATETASKPRIORITY 40\n#define MW_SCHEDULER_INTERRUPT_SOURCE 0\n#define MW_BOARDPARAMETERS_DEVICEADDRESS 192.168.7.2\n#define MW_BOARDPARAMETERS_USERNAME debian\n#define MW_BOARDPARAMETERS_PASSWORD temppwd\n#define MW_RUNTIME_BUILDACTION 2\n#define MW_CLOCKING_CPUCLOCKRATEMHZ 1000\n#define MW_DATAVERSION 2016.02\n\n#endif /* __MW_TARGET_HARDWARE_RESOURCES_H__ */\n\n#endif\n\n#endif\n"},{"name":"linuxinitialize.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2022a\\toolbox\\target\\codertarget\\rtos\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013-2020 The MathWorks, Inc. */\n\n\n/* ---------------------------- */\n/* RTOS-specific headers        */\n/* Note: must be included first */\n/* ---------------------------- */\n#include \"linuxinitialize.h\"\n#include \"rtwtypes.h\"\n/* ---------------------------- */\n/* Required Coder Target header */\n/* ---------------------------- */\n#include \"MW_custom_RTOS_header.h\"\n\n#if defined(MW_SOC_ENABLED) && defined(MW_KERNEL_PROFILING_ON)   \n#include \"kernelprofiler-tp.h\"\n#endif\n\n#if (MW_NUM_APERIODIC_PROXY_TASKS > 0)\n#include \"mw_cpuloadgenerator.h\"\n#endif\n\n#define NAMELEN 16\n\ntypedef struct {\n    void* (*pAsyncTasks)(void* arg);\n    char taskName[NAMELEN];\n    int priority;\n    int policy;\n    int coreSelection;\n    int coreNum;\n} MW_AsyncTaskCodeGenInfo_Type;\n\n#if (defined(MW_TSKMGR_EVENT_DRIVEN_TASKS) && (MW_TSKMGR_EVENT_DRIVEN_TASKS > 0))\nstatic MW_AsyncTaskCodeGenInfo_Type asyncTaskCodeGenInfo[MW_TSKMGR_EVENT_DRIVEN_TASKS];\n\nvoid mw_setAsyncTaskCodeGenInfo(void * (*taskHandler)(void *), \n        const char* taskName, int priority, int policy, \n        int coreSelection, int coreNum, int idx)\n{\n    asyncTaskCodeGenInfo[idx].pAsyncTasks = taskHandler;\n    snprintf(asyncTaskCodeGenInfo[idx].taskName, NAMELEN, \"%s\", taskName);\n    asyncTaskCodeGenInfo[idx].priority = priority;\n    asyncTaskCodeGenInfo[idx].policy = policy;\n    asyncTaskCodeGenInfo[idx].coreSelection = coreSelection;\n    asyncTaskCodeGenInfo[idx].coreNum = coreNum;\n}\n#endif\nextern volatile boolean_T runModel;\n/* ---------------------------- */\n/* RTOS-specific declarations   */\n/* ---------------------------- */\ntypedef struct {\n    double period;\n} baseRateInfo_t;\n\npthread_t baseTimerThread;\n#if (MW_NUM_APERIODIC_PROXY_TASKS > 0)   \npthread_t proxyTaskEventSrcThread;\n#endif\n\npthread_attr_t attr;\nbaseRateInfo_t info;\nstruct sched_param sp;\n\n/* MW_NUM_SUBRATES is set to 0 if we are in single-tasking mode or number of subrates are 0 */\n#define MW_SP_SCHED_FIFO ((MW_NUMBER_SUBRATES > 0) || !defined(MW_SCHED_OTHER))\n#ifdef MW_RTOS_DEBUG\n    #define MW_DEBUG_LOG(str)  printf(str); fflush(stdout)\n#else\n    #define MW_DEBUG_LOG(str)\n#endif\n\n#ifdef MW_HAS_COMM_SERVICE\n    extern int makeCSTaskIdle();\n#endif\n\n#if (MW_NUMBER_TIMER_DRIVEN_TASKS > 0)\n    sem_t timerTaskSem[MW_NUMBER_TIMER_DRIVEN_TASKS];\n    int timer_fd[MW_NUMBER_TIMER_DRIVEN_TASKS];\n    double timer_period[MW_NUMBER_TIMER_DRIVEN_TASKS];\n#endif\n    \nint mw_CreateArmedTimer(double period)\n{\n    int status;\n    int fd;\n    struct itimerspec its;\n\n    /* Create the timer */\n    fd = timerfd_create(CLOCK_MONOTONIC, 0);\n    if (fd == -1) {\n        fprintf(stderr, \"Call to timerfd_create failed.\\n\"); \n        perror(\"timerfd_create\");\n        fflush(stderr); \n        exit(EXIT_FAILURE);\n    }\n\n    /* Make the timer periodic */\n    its.it_value.tv_sec = (time_t)period;\n    its.it_value.tv_nsec = (period - (time_t)period) * 1000000000;\n    its.it_interval.tv_sec = its.it_value.tv_sec;\n    its.it_interval.tv_nsec = its.it_value.tv_nsec;\n    status = timerfd_settime(fd, 0, &its, NULL);\n    CHECK_STATUS(status, 0, \"timer_settime\");\n    \n    return fd;\n}\n\n#if (MW_NUMBER_TIMER_DRIVEN_TASKS > 0)\nvoid mw_init_timerTaskSem(int idx)\n{\n    int status;\n    status = sem_init(&timerTaskSem[idx], 0, 0);\n    CHECK_STATUS(status, 0, \"sem_init:mw_init_timerTaskSem\");\n}\n\nint mw_CreateUnarmedTimer(double period, int idx)\n{\n    int fd;\n    int status;\n\n    /* Create the timer */\n    fd = timerfd_create(CLOCK_MONOTONIC, 0);\n    timer_fd[idx] = fd;\n    timer_period[idx] = period;\n    if (fd == -1) {\n        fprintf(stderr, \"Call to timerfd_create failed.\\n\"); \n        perror(\"timerfd_create\");\n        fflush(stderr); \n        exit(EXIT_FAILURE);\n    }     \n    /* Signal that the timer has been created. */\n    status = sem_post(&timerTaskSem[idx]); \n    CHECK_STATUS(status, 0, \"sem_post:mw_CreateUnarmedTimer\");     \n    #ifdef MW_RTOS_DEBUG\n        printf(\"Created unarmed timer # %d %d.\\n\", fd, idx);\n        fflush(stdout);\n    #endif    \n    return fd;\n}\n#endif\n\n#if (MW_NUMBER_TIMER_DRIVEN_TASKS > 0)\nvoid mw_ArmTimer(int idx)\n{\n    int status;\n    struct itimerspec its;\n    int fd = timer_fd[idx];\n    double period = timer_period[idx];\n    \n    its.it_interval.tv_sec = (time_t)period;\n    its.it_interval.tv_nsec = (period - (time_t)period) * 1000000000;\n    its.it_value.tv_sec = 0;\n    its.it_value.tv_nsec = 1.0;\n    #ifdef MW_RTOS_DEBUG\n        printf(\"About to arm timer # %d %d.\\n\", fd, idx);\n        fflush(stdout);\n    #endif\n    status = timerfd_settime(fd, 0, &its, NULL);\n    #ifdef MW_RTOS_DEBUG\n        printf(\"Armed timer # %d %d.\\n\", fd, idx);\n        fflush(stdout);\n    #endif\n    \n    CHECK_STATUS(status, 0, \"timer_settime\"); \n}\n#endif\n\nvoid mw_WaitForTimerEvent(int fd)\n{\n    unsigned long long missed;\n    int status;\n    \n    /* Wait for the next timer event. If we have missed any the\n       number is written to \"missed\" */\n    while ((status = read(fd, &missed, sizeof(missed)) == -1) && (errno == EINTR)) {\n        /* Restart if interrupted by a signal */\n        continue;\n    }\n    if (status == -1) {\n        perror(\"read(timerfd)\");\n    }\n}\n\nvoid mw_WaitForTimerEventCatchup(int fd)\n{\n    unsigned long long missed = 0;\n    int status = 0;\n    static unsigned int outstanding = 0;\n    \n    /* Wait for the next timer event. If we have missed any the\n     * number is written to \"missed\" */\n    if (outstanding == 0)\n    {\n        while ((status = read(fd, &missed, sizeof(missed)) == -1) && (errno == EINTR)) {\n            /* Restart if interrupted by a signal */\n            continue;\n        }\n        if (status == -1) {\n            perror(\"read(timerfd)\");\n        }\n        if (missed > 1) {\n            #ifdef MW_RTOS_DEBUG\n            printf(\"Missed %llu events for the timer # %d.\\n\", missed, fd);\n            fflush(stdout);\n            #endif\n            outstanding = outstanding + missed - 1;\n        }\n    }\n    else\n    {\n        #ifdef MW_RTOS_DEBUG\n        printf(\"Catching up with the missed events for timer # %d.\\n\", fd);\n        fflush(stdout);\n        #endif\n        outstanding--;\n    }\n}\n\n/* ---------------------------- */\n/* Internally visible functions */\n/* ---------------------------- */\n\n\n#ifdef MW_SOC_ENABLED\nvoid *baseTimerTask(void* arg)\n{\n    /* SOCB product installed and used */\n    int fd;\n    baseRateInfo_t info = *((baseRateInfo_t *)arg);\n\n    MW_DEBUG_LOG(\"baseTimerTask entered\\n\");\n    fd = mw_CreateArmedTimer(info.period);  \n    SOCB_RateCounterFcn();   \n    while(1) {\n        mw_WaitForTimerEvent(fd);\n        SOCB_RateCounterFcn();\n    }\n}\n#if (MW_NUM_APERIODIC_PROXY_TASKS > 0)\nvoid *proxyTaskEventSrcTask(void *unused)\n{\n    int fd;\n    int status;\n    double oldTime;\n    struct itimerspec its; \n    static int cnt = 0;\n    extern SOC_eventSourceDataType SOC_eventSourceData[];\n    SOC_eventSourceDataType *pOldEvent = NULL;\n    SOC_eventSourceDataType *pNewEvent = NULL;\n    pNewEvent = (SOC_eventSourceDataType*) &SOC_eventSourceData[cnt];\n    double period = pNewEvent->time + 1e-9; // cannot be zero\n    fprintf(stderr, \"First timer value %g\\n\", period); \n    fflush(stderr);\n    \n    MW_DEBUG_LOG(\"proxyTaskSrcTask entered\\n\");\n    fd = mw_CreateArmedTimer(period);  \n    while(1) {\n        MW_DEBUG_LOG(\"waiting for proxyTaskSrcTask timer event\\n\");\n        mw_WaitForTimerEvent(fd);\n        MW_DEBUG_LOG(\"got proxyTaskSrcTask timer event\\n\");\n        sem_post(&SOCB_ProxyTaskSem[(int) pNewEvent->semIdx]);\n        /* Update the timer period for the next event */\n        if (++cnt < SOC_MAXEVENTSRCCOUNTER) {\n            pOldEvent = (SOC_eventSourceDataType*) &SOC_eventSourceData[cnt-1];\n            pNewEvent = (SOC_eventSourceDataType*) &SOC_eventSourceData[cnt];\n            period = pNewEvent->time - pOldEvent->time;// what if zero??? \n            fprintf(stderr, \"Next timer value %g\\n\", period);\n            fflush(stderr);\n        } else {\n            period = 0.0;   \n        }\n        its.it_value.tv_sec = (time_t)period;\n        its.it_value.tv_nsec = (period - (time_t)period) * 1000000000;\n        its.it_interval.tv_sec = its.it_value.tv_sec;\n        its.it_interval.tv_nsec = its.it_value.tv_nsec;\n        status = timerfd_settime(fd, 0, &its, NULL);\n        CHECK_STATUS(status, 0, \"timer_settime\");   \n    }\n}\n#endif\n#else \nvoid *schedulerTask(void* arg)\n{\n    /* SOCB product not installed or not used */\n    int fd;\n    baseRateInfo_t info = *((baseRateInfo_t *)arg);\n\n    MW_DEBUG_LOG(\"schedulerTask entered\\n\");\n    fd = mw_CreateArmedTimer(info.period);\n    sem_post(&baserateTaskSem); \n    while(runModel) {\n        mw_WaitForTimerEvent(fd);\n        #ifdef DETECT_OVERRUNS        \n            testForRateOverrun(0);\n        #endif\n        sem_post(&baserateTaskSem);\n    }\n}\n\n#ifdef MW_SCHEDULE_TASK_WITH_ALSA_AUDIO\nvoid *schedulerTaskALSA(void* arg)\n{\n    /*Register the ALSA Audio capture block with base rate */\n    mw_alsa_registerCallback();\n}\n\nvoid triggerBaseRate(void){\n    /*Post the semaphore after period event from ALSA block*/\n    sem_post(&baserateTaskSem);\n}\n#endif\n#endif\n\n\n/* Should use this fcn, but currently are not using it */\n/* Why: it is safe ??? from interruption */\nvoid my_sem_wait(sem_t *sem)\n{\n    int status;\n    while (((status = sem_wait(sem)) == -1) && (errno == EINTR)) {\n        /* Restart if interrupted by a signal */\n        continue;\n    }\n    CHECK_STATUS(status, 0, \"my_sem_wait\");\n}\n\nstatic void setThreadPriority(const int priority, pthread_attr_t *attr, struct sched_param *sp)\n{\n#if MW_SP_SCHED_FIFO\n    int status;\n    \n    sp->sched_priority = priority;\n    status = pthread_attr_setschedparam(attr, sp);\n    CHECK_STATUS(status, 0, \"pthread_attr_setschedparam\");\n#endif\n}\n\n/* ---------------------------- */\n/* Externally visible functions */\n/* ---------------------------- */\n\nvoid mw_CreateTask(void * (*taskHandler)(void *), const char* taskName, int priority, int policy, int coreSelection, int coreNum)\n{\n    int status;\n    int inherit;\n    pthread_attr_t attr;\n    pthread_t thread;\n    struct sched_param param;\n    size_t stackSize;\n    pthread_attr_init(&attr);\n    cpu_set_t cpuset;\n#ifdef MW_TSKMGR_TIMER_DRIVEN_TASKS\n    char thisTaskName[MW_MAX_TASKNAME];\n#endif\n\n    /* Set thread inherit attribute */\n    inherit = PTHREAD_EXPLICIT_SCHED;\n    status = pthread_attr_setinheritsched(&attr, inherit);\n    CHECK_STATUS(status, 0, \"pthread_attr_setinheritsched\");\n\n    /* Set thread detach attribute */\n    status = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n    CHECK_STATUS(status, 0, \"pthread_attr_setdetachstate\");\n\n    /* Set thread stack size attribute */\n    stackSize = (512 > PTHREAD_STACK_MIN) ? 512:PTHREAD_STACK_MIN;\n    status = pthread_attr_setstacksize(&attr, stackSize);\n    CHECK_STATUS(status, 0, \"pthread_attr_setstacksize\");\n\n    /* Set thread schedule policy attribute */\n    policy = SCHED_FIFO;\n    status = pthread_attr_setschedpolicy(&attr, policy);\n    CHECK_STATUS(status, 0, \"pthread_attr_setschedpolicy\");\n\n    /* Set thread priority attribute */\n    param.sched_priority = priority;\n    status = pthread_attr_setschedparam(&attr, &param);\n    CHECK_STATUS(status, 0, \"pthread_attr_setschedparam\");\n    \n    /* Set the thread core affinity */\n    if (2 == coreSelection) \n    {\n        CPU_ZERO(&cpuset);\n        CPU_SET(coreNum, &cpuset);\n        status =  pthread_attr_setaffinity_np(&attr, sizeof(cpu_set_t), &cpuset);\n        CHECK_STATUS(status, 0, \"pthread_attr_setaffinity_np\");\n    }\n\n    /* Create the thread */\n    status = pthread_create(&thread, &attr, taskHandler, NULL);\n    CHECK_STATUS(status, 0, \"pthread_create\");\n#ifdef MW_TSKMGR_TIMER_DRIVEN_TASKS\n    /* Set name of the thread */\n    snprintf(thisTaskName, MW_MAX_TASKNAME, \"%s\", taskName);\n    status = pthread_setname_np(thread, thisTaskName);\n    CHECK_STATUS(status, 0, \"pthread_setname_np at mw_CreateTask\");\n#endif\n    pthread_attr_destroy(&attr);\n}\n\nvoid myAddBlockForThisEvent(int sigNo)\n{\n    int status;\n    sigset_t sigMask;\n\n    sigemptyset(&sigMask);\n    sigaddset(&sigMask, sigNo);\n    status = pthread_sigmask(SIG_BLOCK, &sigMask, NULL);\n    CHECK_STATUS(status, 0, \"pthread_sigmask\");\n}\n\nvoid myAddHandlerForThisEvent(int sigNo, int sigToBlock[], int numSigToBlock, void (*sigHandler)(int))\n{\n    int idx;\n    int status;\n    struct sigaction sa;\n\n    sa.sa_handler = (__sighandler_t) sigHandler;\n    sigemptyset(&sa.sa_mask);\n    for (idx=0; idx<numSigToBlock; idx++) {\n            sigaddset(&sa.sa_mask, sigToBlock[idx]);\n    }\n    sa.sa_flags = SA_RESTART; /* Restart functions if interrupted by handler */\n    status = sigaction(sigNo, &sa, NULL);\n    CHECK_STATUS_NOT(status, -1, \"sigaction to register a signal handler\");\n}\n\nvoid myRestoreDefaultHandlerForThisEvent(int sigNo)\n{\n    int status;\n    struct sigaction sa;\n    sa.sa_handler = SIG_DFL;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = SA_RESTART; /* Restart functions if interrupted by handler */\n    status = sigaction(sigNo, &sa, NULL);\n    CHECK_STATUS_NOT(status, -1, \"sigaction to restore default signal handler\");\n}\n\n/* ***********************************************************************/\n/* ***********************************************************************/\n/* ***********************************************************************/\n\nvoid myRTOSInit(double baseRatePeriod, int numSubrates)\n{\n    int i;\n    int status;\n    uid_t euid;\n    size_t stackSize;\n    unsigned long cpuMask = 0x1;\n    unsigned int len = sizeof(cpuMask);  \n#ifdef MW_TSKMGR_TIMER_DRIVEN_TASKS\n    char thisTaskName[MW_MAX_TASKNAME];\n#endif\n\n#if (defined(MW_TSKMGR_EVENT_DRIVEN_TASKS) && (MW_TSKMGR_EVENT_DRIVEN_TASKS > 0))\n    {\n        int idx;\n        for (idx=0;idx < MW_TSKMGR_EVENT_DRIVEN_TASKS;idx++)\n        {\n            mw_CreateTask(asyncTaskCodeGenInfo[idx].pAsyncTasks, \\\n                    (const char*) asyncTaskCodeGenInfo[idx].taskName,\\\n                    asyncTaskCodeGenInfo[idx].priority, \\\n                    asyncTaskCodeGenInfo[idx].policy, \\\n                    asyncTaskCodeGenInfo[idx].coreSelection, \\\n                    asyncTaskCodeGenInfo[idx].coreNum);\n#if defined(MW_SOC_ENABLED)\n    /* pause the main thread for 50us, so that main thread goes to waiting state and event driven tasks initialize properly. */\n    /* event driven tasks take ~30-40 us for the initialization.*/\n    /* for more information refer geck 2045382. */        \n\t\t\tusleep(50);\n#endif\n        }\n    }\n#endif\n    UNUSED(baseRatePeriod);\n    UNUSED(numSubrates);\n        \n    if (!MW_IS_CONCURRENT) {\n        /* All threads created by this process will run on a single CPU */\n        status = sched_setaffinity(0, len, (cpu_set_t *) &cpuMask);\n        CHECK_STATUS(status, 0, \"sched_setaffinity\");\n    }\n\n#if MW_SP_SCHED_FIFO && !defined (_POSIX_THREAD_PRIORITY_SCHEDULING)\n    fprintf(stderr, \"Priority scheduling is NOT supported by your system.\\n\");\n    fprintf(stderr, \"The generated code will not run correctly because your\\n\");\n    fprintf(stderr, \"model contains multiple rates and uses multi-tasking\\n\");\n    fprintf(stderr, \"code generation mode. You can only run the generated code\\n\");\n    fprintf(stderr, \"in single-tasking mode in your system. Open\\n\");\n    fprintf(stderr, \"Simulation -> Configuration Parameters -> Solver dialog\\n\");\n    fprintf(stderr, \"and set \\\"Tasking mode for periodic sample times\\\" parameter to SingleTasking.\\n\");\n    fprintf(stderr, \"Re-build the Simulink model with the new settings and try executing the generated code again.\\n\");\n    fflush(stderr);\n    exit(EXIT_FAILURE);\n#endif\n    \n#if MW_SP_SCHED_FIFO\n    /* Need root privileges for real-time scheduling */\n    euid = geteuid();\n    if (euid != 0) {\n        fprintf(stderr, \"You must have root privileges to run the generated code because\\n\");\n        fprintf(stderr, \"generated code requires SCHED_FIFO scheduling class to run correctly.\\n\");\n        fprintf(stderr, \"Try running the executable with the following command: sudo ./<executable name>\\n\");\n        fflush(stderr);\n        exit(EXIT_FAILURE);\n    }\n#endif\n\n    status = sem_init(&baserateTaskSem, 0, 0);\n    CHECK_STATUS(status, 0, \"sem_init:baserateTaskSemSem\");\n    status = sem_init(&stopSem, 0, 0);\n    CHECK_STATUS(status, 0, \"sem_init:stopSem\");\n    \n#if MW_SP_SCHED_FIFO\n    /* Set scheduling policy of the main thread to SCHED_FIFO */\n    sp.sched_priority = sched_get_priority_max(SCHED_FIFO);\n    status = sched_setscheduler(0, SCHED_FIFO, &sp);\n    CHECK_STATUS(status, 0, \"sched_setscheduler\");\n#endif\n\n    /* Create threads executing the Simulink model */\n    pthread_attr_init(&attr);\n    status = pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);\n    CHECK_STATUS(status, 0, \"pthread_attr_setinheritsched\");\n#if MW_SP_SCHED_FIFO\n    status = pthread_attr_setschedpolicy(&attr, SCHED_FIFO);\n#else\n    status = pthread_attr_setschedpolicy(&attr, SCHED_OTHER);\n#endif\n    CHECK_STATUS(status, 0, \"pthread_attr_setschedpolicy\");\n    status = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n    CHECK_STATUS(status, 0, \"pthread_attr_setdetachstate\");\n\n    /* Set thread stack size if necessary */\n    status = pthread_attr_getstacksize(&attr, &stackSize);\n    CHECK_STATUS(status, 0, \"pthread_attr_getstacksize\");\n    if (stackSize < STACK_SIZE) {\n        /* Make sure that stackSize is a multiple of 8 */\n        stackSize = (STACK_SIZE + 7) & (~0x7);\n        pthread_attr_setstacksize(&attr, stackSize);\n        CHECK_STATUS(status, 0, \"pthread_attr_setstacksize\");\n    }\n\n    signal(SIGTERM, exitFcn);     /* kill */\n    signal(SIGHUP, exitFcn);      /* kill -HUP */\n    signal(SIGINT, exitFcn);      /* Interrupt from keyboard */\n    signal(SIGQUIT, exitFcn);     /* Quit from keyboard */\n\n#ifdef MW_STANDALONE_EXECUTION_PROFILER_ON\n    status = pthread_mutex_init(&profilingDataStoreMutex, NULL);    \n#endif\n    \n#ifdef MW_HAS_MULTIPLE_RATES\n    MW_DEBUG_LOG(\"**creating subrate task threads**\\n\");   \n    for (i = 0; i < MW_NUMBER_SUBRATES; i++) {\n        taskId[i] = i;\n        status = sem_init(&subrateTaskSem[i], 0, 0);\n        CHECK_STATUS(status, 0, \"sem_init\");\n        setThreadPriority(subratePriority[i], &attr, &sp);\n        status = pthread_create(&subRateThread[i], &attr, &subrateTask, (void *)&taskId[i]);\n        CHECK_STATUS(status, 0, \"pthread_create\");\n#ifdef MW_TSKMGR_TIMER_DRIVEN_TASKS\n        /* Set name of sub-rate threads */\n        snprintf(thisTaskName, MW_MAX_TASKNAME, \"%s\", _mwTskMgrTimerDrivenTaskNames[i+1]);\n        MW_DEBUG_LOG(thisTaskName);   \n        status = pthread_setname_np(subRateThread[i], thisTaskName);\n        CHECK_STATUS(status, 0, \"pthread_setname_np at subRateThread\");\n#endif        \n#if !defined(MW_SOC_ENABLED) && defined(DETECT_OVERRUNS)\n        status = pthread_mutex_init(&rateTaskFcnRunningMutex[i+1], NULL);\n        CHECK_STATUS(status, 0, \"pthread_mutex_init\");\n#endif        \n#ifdef COREAFFINITYREQUIRED\n        if (coreAffinity[i] >= 0) {\n             cpu_set_t cpuset;\n             CPU_ZERO(&cpuset);\n             CPU_SET(coreAffinity[i], &cpuset);\n             status = pthread_setaffinity_np(subRateThread[i], sizeof(cpu_set_t), &cpuset);\n             CHECK_STATUS(status, 0, \"pthread_setaffinity_np\");\n         }\n#endif\n    }\n#endif\n\n    MW_DEBUG_LOG(\"**creating the base rate task thread**\\n\");    \n    setThreadPriority(MW_BASERATE_PRIORITY, &attr, &sp);  \n    status = pthread_create(&baseRateThread, &attr, &baseRateTask, NULL);\n    CHECK_STATUS(status, 0, \"pthread_create\");\n    \n#ifdef MW_TSKMGR_TIMER_DRIVEN_TASKS\n    /* Set name of the base-rate thread */\n    snprintf(thisTaskName, MW_MAX_TASKNAME, _mwTskMgrTimerDrivenTaskNames[0]);\n    status = pthread_setname_np(baseRateThread, thisTaskName);\n    CHECK_STATUS(status, 0, \"pthread_setname_np at baserateThread\");\n#endif\n    \n#if !defined(MW_SOC_ENABLED) && defined(DETECT_OVERRUNS)\n    status = pthread_mutex_init(&rateTaskFcnRunningMutex[0], NULL);\n    CHECK_STATUS(status, 0, \"pthread_mutex_init\");\n#endif\n\n#ifdef COREAFFINITYREQUIRED\n    if (coreAffinityBaseRate >= 0) {\n        cpu_set_t cpuset;\n        CPU_ZERO(&cpuset);\n        CPU_SET(coreAffinityBaseRate, &cpuset);\n        status = pthread_setaffinity_np(baseRateThread, sizeof(cpu_set_t), &cpuset);\n        CHECK_STATUS(status, 0, \"pthread_setaffinity_np\");\n    }   \n#endif\n\n#ifdef MW_SOC_ENABLED    \n#if (MW_NUM_APERIODIC_PROXY_TASKS > 0)    \n    MW_DEBUG_LOG(\"**creating the socb proxy task event src thread **\\n\");  \n    /* Set the priority just below the highest possible */    \n    setThreadPriority(sched_get_priority_max(SCHED_FIFO)-1, &attr, &sp);\n    status = pthread_create(&proxyTaskEventSrcThread, &attr, &proxyTaskEventSrcTask, NULL);\n    CHECK_STATUS(status, 0, \"pthread_create\");\n    status = pthread_setname_np(proxyTaskEventSrcThread, \"proxyTaskEventSrcTask\"); \n#endif    \n    MW_DEBUG_LOG(\"**creating the socb base rate timer handler thread**\\n\");  \n    /* Set the priority the highest possible */  \n    setThreadPriority(sched_get_priority_max(SCHED_FIFO), &attr, &sp);\n    info.period = MW_BASERATE_PERIOD;\n    status = pthread_create(&baseTimerThread, &attr, &baseTimerTask, (void *) &info);\n    CHECK_STATUS(status, 0, \"pthread_create\");\n    status = pthread_setname_np(baseTimerThread, \"baseTimerTask\");\n#endif \n    \n    MW_DEBUG_LOG(\"**creating the scheduler thread**\\n\");  \n    #ifdef MW_SCHEDULE_TASK_WITH_ALSA_AUDIO\n        status = pthread_create(&schedulerThread, &attr, &schedulerTaskALSA, (void *) &info);\n    #else\n        /* Set the priority higher (higher number) than the base rate */    \n        setThreadPriority(MW_BASERATE_PRIORITY + 1, &attr, &sp);\n        info.period = MW_BASERATE_PERIOD;\n        status = pthread_create(&schedulerThread, &attr, &schedulerTask, (void *) &info);\n    #endif\n    CHECK_STATUS(status, 0, \"pthread_create\");\n       \n#ifdef MW_TSKMGR_TIMER_DRIVEN_TASKS\n    /* Set name of the scheduler thread */\n    snprintf(thisTaskName, MW_MAX_TASKNAME, \"scheduler\");\n    status = pthread_setname_np(schedulerThread, thisTaskName);\n    CHECK_STATUS(status, 0, \"pthread_setname_np at scheduler thread\");\n#endif\n\n#ifdef MW_HAS_APERIODIC_TASKS\n    MW_DEBUG_LOG(\"**creating asynchronously triggered task threads**\\n\"); \n    /* Set the priority higher (higher number) than the base rate */    \n    sp.sched_priority = MW_BASERATE_PRIORITY + 1;\n    for (i = 0; i < MW_NUMBER_APERIODIC_TASKS; i++) {\n        status = pthread_create(&asyncThread[i], &attr, (void *) pAsyncTasks[i], NULL);\n        CHECK_STATUS(status, 0, \"pthread_create\");\n    }\n#endif\n    \n#ifdef MW_NEEDS_BACKGROUND_TASK\n    MW_DEBUG_LOG(\"**creating the background thread**\\n\");\n    status = pthread_attr_setschedpolicy(&attr, SCHED_OTHER);\n    CHECK_STATUS(status, 0, \"pthread_attr_setschedpolicy\");\n    setThreadPriority(0, &attr, &sp);\n    status = pthread_create(&backgroundThread, &attr, &backgroundTask, NULL);\n    CHECK_STATUS(status, 0, \"pthread_create\");\n#ifdef MW_TSKMGR_TIMER_DRIVEN_TASKS\n    /* Set name of the background thread */\n    snprintf(thisTaskName, MW_MAX_TASKNAME, \"background\");\n    status = pthread_setname_np(backgroundThread, thisTaskName);\n    CHECK_STATUS(status, 0, \"pthread_setname_np at backgroundThread\");\n#endif \n#if MW_SP_SCHED_FIFO == 0\n    status = pthread_setschedparam(backgroundThread, SCHED_IDLE, &sp);\n    CHECK_STATUS(status, 0, \"pthread_setschedparam\");\n#ifdef MW_HAS_COMM_SERVICE\n    status = makeCSTaskIdle();\n    CHECK_STATUS(status, 0, \"pthread_setschedparam\");\n#endif \n#endif\n#endif\n\n    pthread_attr_destroy(&attr);\n    fflush(stdout);\n}\n"}]};